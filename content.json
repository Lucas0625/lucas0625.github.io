{"meta":{"title":"Mr.wang","subtitle":null,"description":null,"author":"琛","url":"http://lucas0625.github.io"},"pages":[{"title":"About","date":"2018-09-10T03:49:10.738Z","updated":"2018-09-08T06:55:26.127Z","comments":true,"path":"about/index.html","permalink":"http://lucas0625.github.io/about/index.html","excerpt":"","text":"个人信息 姓名：Lucas 性别：男 电子邮箱：wangchen_jh@outlook.com Wechat：751009328 目前状态：格式化大脑中。。。"},{"title":"Categories","date":"2018-09-08T06:37:22.081Z","updated":"2018-09-08T04:58:10.828Z","comments":true,"path":"categories/index.html","permalink":"http://lucas0625.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-09-13T02:10:42.278Z","updated":"2018-09-08T04:58:10.828Z","comments":true,"path":"tags/index.html","permalink":"http://lucas0625.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Python 编码规范","slug":"Python-编码规范","date":"2018-10-08T16:00:00.000Z","updated":"2018-10-09T13:08:43.147Z","comments":true,"path":"2018/10/09/Python-编码规范/","link":"","permalink":"http://lucas0625.github.io/2018/10/09/Python-编码规范/","excerpt":"遵循良好的编码风格，可以有效的提高代码的可读性，降低出错几率和维护难度。在团队开发中，使用（尽量）统一的编码风格，还可以降低沟通成本。","text":"遵循良好的编码风格，可以有效的提高代码的可读性，降低出错几率和维护难度。在团队开发中，使用（尽量）统一的编码风格，还可以降低沟通成本。 缩紧 不要使用 tab 缩进 使用任何编辑器写 Python，请把一个 tab 展开为 4 个空格 绝对不要混用 tab 和空格，否则容易出现 IndentationError 空格 在 list, dict, tuple, set, 参数列表的 , 后面加一个空格 在 dict 的 : 后面加一个空格 在注释符号 # 后面加一个空格，但是 #!/usr/bin/python 的 # 后不能有空格 操作符两端加一个空格，如 +, -, *, /, |, &amp;, = 接上一条，在参数列表里的 =两端不需要空格 括号((), {}, [])内的两端不需要空格 空行 function 和 class 顶上两个空行 class 的 method 之间一个空行 函数内逻辑无关的段落之间空一行，不要过度使用空行 不要把多个语句写在一行，然后用 ; 隔开 if/for/while 语句中，即使执行语句只有一句，也要另起一行 换行 每一行代码控制在80字符以内 使用\\或()控制换行，举例： 12345678def foo(first, second, third, fourth, fifth, sixth, and_some_other_very_long_param): user = User.objects.filter_by(first=first, second=second, third=third) \\ .skip(100).limit(100) \\ .all()text = ('Long strings can be made up ' 'of several shorter strings.') 命名 使用有意义的，英文单词或词组，绝对不要使用汉语拼音 package/module 名中不要出现 - 各种类型的命名规范： import 所有 import 尽量放在文件开头，在 docstring 下面，其他变量定义的上面 不要使用 from foo imort * import 需要分组，每组之间一个空行，每个分组内的顺序尽量采用字典序，分组顺序是： 1.标准库 2.第三方库 3.本项目的 package 和 module 不要使用隐式的相对导入（implicit relative imports），可是使用显示的相对导入（explicit relative imports），如 from ..utils import validator，最好使用全路径导入（absolute imports） 对于不同的 package，一个 import 单独一行，同一个 package/module 下的内容可以写一起 为了避免可能出现的命名冲突，可以使用 as 或导入上一级命名空间 不要出现循环导入(cyclic import) 注释 文档字符串 docstring, 是 package, module, class, method, function 级别的注释，可以通过 __doc__ 成员访问到，注释内容在一对 &quot;&quot;&quot; 符号之间 function, method 的文档字符串应当描述其功能、输入参数、返回值，如果有复杂的算法和实现，也需要写清楚 不要写错误的注释，不要无谓的注释 优先使用英文写注释，英文不好全部写中文，否则更加看不懂 异常 不要轻易使用 try/except except 后面需要指定捕捉的异常，裸露的 except 会捕捉所有异常，意味着会隐藏潜在的问题 可以有多个 except 语句，捕捉多种异常，分别做异常处理 使用 finally 子句来处理一些收尾操作 try/except 里的内容不要太多，只在可能抛出异常的地方使用 从 Exception 而不是 BaseException 继承自定义的异常类 Class(类) 显示的写明父类，如果不是继承自别的类，就继承自 object 类 使用 super 调用父类的方法 支持多继承，即同时有多个父类，建议使用 Mixin 编码建议字符串 使用字符串的 join 方法拼接字符串 使用字符串类型的方法，而不是 string 模块的方法 使用 startswith 和 endswith 方法比较前缀和后缀 使用 format 方法格式化字符串 比较 空的 list, str, tuple, set, dict 和 0, 0.0, None 都是 False 使用 if some_list 而不是 if len(some_list) 判断某个 list 是否为空，其他类型同理 使用 is 和 is not 与单例（如 None）进行比较，而不是用 == 和 != 使用 if a is not None 而不是 if not a is None 用 isinstance 而不是 type 判断类型 不要用 == 和 != 与 True 和 False 比较（除非有特殊情况，如在 sqlalchemy 中可能用到） 使用 in 操作: 用 key in dict 而不是 dict.has_key() 用 set 加速 “存在性” 检查，list 的查找是线性的，复杂度 O(n)，set 底层是 hash table, 复杂度 O(1)，但用 set需要比 list 更多内存空间 其他 使用列表表达式（list comprehension），字典表达式(dict comprehension, Python 2.7+) 和生成器(generator) dict 的 get 方法可以指定默认值，但有些时候应该用 [] 操作，使得可以抛出 KeyError 使用 for item in list 迭代 list, for index, item in enumerate(list) 迭代 list 并获取下标 使用内建函数 sorted 和 list.sort 进行排序 适量使用map, reduce, filter 和 lambda，使用内建的 all, any 处理多个条件的判断 使用 defaultdict (Python 2.5+), Counter(Python 2.7+) 等 “冷门” 但好用的标准库算法和数据结构 使用装饰器(decorator) 使用 with 语句处理上下文 有些时候不要对类型做太过严格的限制，利用 Python 的鸭子类型（Duck Type）特性 使用 logging 记录日志，配置好格式和级别 了解 Python 的 Magic Method：A Guide to Python’s Magic Methods, Python 魔术方法指南 阅读优秀的开源代码，如 Flask 框架, Requests for Humans 不要重复造轮子，查看标准库、PyPi、Github、Google 等使用现有的优秀的解决方案","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://lucas0625.github.io/categories/PYTHON/"}],"tags":[{"name":"经验","slug":"经验","permalink":"http://lucas0625.github.io/tags/经验/"}]},{"title":"深入理解 Python package","slug":"深入理解Python-package","date":"2018-10-07T16:00:00.000Z","updated":"2018-10-08T13:28:24.378Z","comments":true,"path":"2018/10/08/深入理解Python-package/","link":"","permalink":"http://lucas0625.github.io/2018/10/08/深入理解Python-package/","excerpt":"Python 是通过 module 组织代码的，module 即一个 py 文件，module 又是通过 package 来组织的，package 是一个包含 __init__.py 的文件夹，代码，module，package 它们三者的关系就是：module 包含代码，package 至少包含一个为 __init__.py 的 module。 12345package├── __init__.py├── submodule.py└── subpackage └── __init__.py","text":"Python 是通过 module 组织代码的，module 即一个 py 文件，module 又是通过 package 来组织的，package 是一个包含 __init__.py 的文件夹，代码，module，package 它们三者的关系就是：module 包含代码，package 至少包含一个为 __init__.py 的 module。 12345package├── __init__.py├── submodule.py└── subpackage └── __init__.py 空的 __init__.py不包含任何代码的 __init__.py 只用来标识一个文件夹是一个 package，而 package 是可以被导出的。 1from package import item 此处的 item 可以是 package 中包含的 submodule 或 subpackage。 12from package import submodulefrom package import subpackage 不为空 __init__.py如果 __init__.py 不为空，其中包含的任何变量，包括 function、class、variable 以及 任何被导入的 module 都可以通过 package 导出。 1from package import item 此处的 item 可以是 __init__.py中的任何变量 package的初始化工作一个 package 被导入，不管在什么时候 __init__.py 中的代码只执行一次。 12345&gt;&gt;&gt; import packagehello world&gt;&gt;&gt; import package&gt;&gt;&gt; import package&gt;&gt;&gt; 由于 package 被导入时__init__.py 中的可执行代码会被执行，所以小心在 package 中放置你的代码，尽可能消除它们产生的副作用，比如把代码尽可能的进行封装成函数或类。 从package中倒入变量的顺序1from package import item import 语句首先检查 item 是否是 __init__.py 中定义的变量，然后检查其是不是一个 subpackage，如果不是再去检查其是不是一个 module，都不是将抛出 ImportError。 在 import item.subitem.subsubitem 语句时，除了最后一个 subsubitem 之外其他 item 都必须是 package，而最后一个 subsubitem 必须是一个 package 或者 module，不能是他前一个 item 定义的 function、class、variable。 使用*导入在 from package import *语句中，如果 __init__.py 中定义了 __all__ 变量，一个 list，仅仅只有这个 list 中定义的 submodule 或者变量将会被导出。 如果__init__.py中没有__all__变量，导出将按照一下规则执行： 此 package 被导入，并且执行 __init__.py 中可被执行的代码 __init__.py 中定义的 variable 被导入 __init__.py 中被显式导入的 module 被导入","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://lucas0625.github.io/categories/PYTHON/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://lucas0625.github.io/tags/基础/"}]},{"title":"python 格式化显示字符串","slug":"json","date":"2018-09-16T08:30:18.409Z","updated":"2018-10-08T13:28:11.964Z","comments":true,"path":"2018/09/16/json/","link":"","permalink":"http://lucas0625.github.io/2018/09/16/json/","excerpt":"","text":"12import jsonjson.dumps(dict, indent=4)","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://lucas0625.github.io/categories/PYTHON/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://lucas0625.github.io/tags/技巧/"}]},{"title":"算法和数据结构","slug":"Algorithms and Data Structures;","date":"2018-09-11T13:17:13.800Z","updated":"2018-09-16T08:35:39.377Z","comments":true,"path":"2018/09/11/Algorithms and Data Structures;/","link":"","permalink":"http://lucas0625.github.io/2018/09/11/Algorithms and Data Structures;/","excerpt":"数据结构数据结构就是关系，数据元素相互之间存在的一种或多种特定关系的集合","text":"数据结构数据结构就是关系，数据元素相互之间存在的一种或多种特定关系的集合 逻辑结构和物理结构逻辑结构： 指数据对象中数据元素之间的相互关系，也是今后最需要关注和讨论的问题 逻辑结构指数据的逻辑结构在计算机中的存储形式 四大逻辑结构： 集合结构： 同属一个集合 线性结构： 一对一 树形结构： 一对多 图形结构： 多对多 物理结构 存储器： 主要针对内存而言，想赢盘，光盘 数据存储结构形式： 顺序存储，链式存储 顺序存储： 数据元素存放在地址连续的存储单元里，其数据的逻辑关系和物理关系是一致的链式存储： 把数据元素放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的 算法算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作 算法的五个基本特征： 输入：零个或多个输入 输出： 至少有一个或多个输出 有穷行： 算法在执行有限的步骤之后，自动结束而不会出现无限循环 确定性： 每一个步骤都具有确定的含义 可行性： 每一步都必须是可行的 算法设计的要求 正确性 可读性 健壮性 时间效率高和存储量低 算法效率的度量方法运行时间主要取决因素 算法采用的策略，方案 编译产生的代码质量 问题的输入规模 机器执行指令的速度 分析算法的运行时间时，重要的是把基本操作的数量和输入模式关联起来可以忽略的项 常数可以忽略 与最高次项相乘的常数可以忽略 其他次项（除去最高项）时间复杂度定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间度量，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。记法：O()，大O记法推导大O阶： 用常数1取代运行时间中的所有假发常数 在修改后的运行次数函数中，只保留最高阶项 如果最高阶存在且不是1，则去除与这个项相乘的常数 得到的最后结果就是大O阶最常用的大O阶1.O(1) 常数阶2.O(n) 线形阶3.O(n^2 ) 平方阶4.O(logn) 对数阶5.O(nlogn) nlogn阶6.O(n^3 ) 立方阶7.O(2^n ) 指数阶空间复杂度算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式：S(n)=O(f(n))，其中，n为问题规模，f(n)为语句关于n所占存储空间的函数通常，我们都是用时间复杂度来指运行时间的需求，用空间复杂度来指空间需求","categories":[{"name":"算法","slug":"算法","permalink":"http://lucas0625.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://lucas0625.github.io/tags/算法/"}]}]}